# ⭐ SQL

<details>

<summary> ✏ 데이터 모델링의 이해 </summary>
<div markdown="1">
  
## 1. 
### 1️⃣ 모델링의 이해
#### 모델링의 정의
- 현실시계를 추상화, 단순화, 명확화하기 위해 일정한 표기법에 의해 표현하는 기법.
  
#### 모델링의 특징
- ##### `추상화(모형화, 가설적)`
    - 현실세계를 일정한 형식에 맞추어 표현을 한다는 의미. 즉, 다양한 현상을 일정한 양식인 표기법에 의해 표현한다는 것.
- ##### `단순화`
    - 복잡한 현실 세계를 약속된 규약에 의해 제한된 표기법이나 언어로 표현하여 쉽게 이해할 수 있도록 하는 개념.
- ##### `명확화`
    - 누구나 이해하기 쉽게 하기 위해 대상에 대한 애매모호함을 제거하고 정확하게 현상을 기술하는 것.
  
#### 모델링의 세 가지 관점
- ##### `데이터 관점`
    - 업무가 어떤 데이터와 관련이 있는지 또는 데이터간의 관계는 무엇인지에 대해서 모델링하는 방법(What, Data).
- ##### `프로세스 관점`
    - 업무가 실제하고 있는 일은 무엇인지 또는 무엇을 해야하는지를 모델링하는 방법(How, Process).
- ##### `데이터와 프로세스의 상관 관점`
    - 업무가 처리하는 일의 방법에 따라 데이터는 어떻게 영향을 받고 있는지 모델링하는 방법(Interaction).
  
### 2️⃣ 데이터 모델의 기본 개념의 이해
#### 데이터 모델링의 정의
- 정보시스템을 구축하기 위한 데이터관점의 업무 분석 기법.
- 현실세계의 데이터(what)에 대해 약속된 표기법에 의해 표현하는 과정.
- 데이터베이스를 구축하기 위한 분석/설계의 과정.
  
#### 데이터 모델링을 하는 주요한 이유
- 정보 시스템 구축의 대상이 되는 업무 내용을 정확하게 분석하는 것.
- 분석된 모델을 가지고 실제 데이터베이스를 생성하여 개발 및 데이터관리에 사용하기 위한것.
  
#### 데이터 모델이 제공하는 기능
- 시스템을 현재 또는 원하는 모습으로 가시화하도록 도와준다.
- 시스템의 구조와 행동을 명세화 할 수 있게 한다.
- 시스템을 구축하는 구조화된 틀을 제공한다.
- 시스템을 구축하는 과정 결정한 것을 문서화한다.
- 다양한 영역에 집중하기 위해 다른 영역의 세부 사항은 숨기는 다양한 관점을 제공한다.
- 특정 목표에 따라 구체화된 상세 수준의 표현방법을 제공한다.
  
### 3️⃣ 데이터 모델링의 중요성 및 유의점
- ##### `파급효과`
    - 각 단위 테스트들이 성공적으로 수행되고 완료되면 이를 전체를 묶어서 병행 테스트, 통합테스트를 수행한다.
    - 이 시점에서 데이터 모델의 병경이 불가피한 상황이 발생한다면, 데이터 구조의 변경으로 인한 일련의 변경 작업은 전체 시스템 구축 프로젝트에서 큰 위험요소가 될 수 있다.
    - 이러한 이유로 시스템 구축 작업 중에서 데이터 설계가 중요하다.
- ##### `복잡한 정보 요구사항의 간결한 표현`
    - 정보 요구사항을 파악하는 가장 좋은 방법은 수많은 페이지의 기능적인 요구사항을 파악하는 것보다 간결하게 그려져 있는 데이터 모델을 리뷰하면서 파악하는 것이 훨씬 빠른 방법이다.
- ##### `데이터 품질`
    - 중복 데이터의 미지정, 데이터 구조의 비즈니스 정의의 불충분, 동일한 성격의 데이터를 통합하지 않고 분리함으로써의 나타나는 데이터 불일지 등의 데이터 구조의 문제로 인한 데이터 품질의 문제는 치유하기 불가능한 경우가 대부분이다.
  
#### 데이터 모델링을 할 때 유의점
- ##### `중복(Duplication) 데이터 모델`
    - 같은 데이터를 사용하는 사람, 시간 그리고 장소를 파악하는데 도움을 준다.
    - 이러한 지식 응용은 데이터 베이스가 여러 장소에 같은 정보를 저장하는 잘못을 하지 않도록 한다.
- ##### `비유연성(Inflexibility) 데이터 모델`
    - 이 데이터 모델을 어떻게 설계했느냐에 따라 사소한 업무변화에도 데이터 모델이 수시로 변경됨으로써 유지보수의 어려움을 가중시킬 수 있다.
    - 데이터의 정의를 데이터의 사용 프로세스와 분리함으로써 데이터 모델링은 데이터 혹은 프로세스의 작은 변화가 애플리케이션과 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다.
- ##### `비일관성(Inconsistency) 데이터 모델`
    - 데이터의 중복이 없더라도 비일관성은 발생한다.
    - 데이터 모델링을 할 때 데이터와 데이터 간의 상호 연관 관계에 대한 명확한 정의는 이러한 위험을 사전에 예방할 수 있도록 해준다.

### 4️⃣ 데이터 모델링의 3단계 진행
- ##### `개념적 데이터 모델링`
    - 주요한 활동: 핵심 엔터티와 그들 간의 관계를 발견하고, 그것을 표현하기 위해서 엔터테-관계 다이어그램을 형성하는 것.
    - 사용자와 시스템 개발자가 데이터 요구 사항을 발견하는 것을 지원한다.
    - 현 시스템이 어떻게 변형되어야 하는가를 이해하는데 유용하다.
- ##### `논리적 데이터 모델링`
    - 데이터베이스 설계 프로세스의 input으로써 비즈니스 정보의 논리적인 구조와 규칙을 명확하게 표현하는 기법 또는 과정.
    - 데이터 모델링 과정에서 가장 핵심이 부분.
    - 핵심은 어떻게 데이터에 엑세스하고 누가 데이터에 엑세스하며, 그러한 엑세스의 전산화와는 독립적으로 다시 말해서 누가, 어떻게, 그리고 전산화와는 별개로 비즈니스 데이터에 존재하는 사실들을 인식하여 기록하는 것.
    - ##### 주요활동: `정규화`
        - 논리 데이터 모델의 일관성을 확보하고 중복을 제거하여 속성들이 가장 적절한 엔터티에 배치되도록 함으로써 보다 신뢰성 있는 데이터 구조를 얻는것이 목적.
    - ##### `상세화`
        - 식별자 확정, 정규화, M:M 관계 해소, 참조 무결성 규칙 정의.
- ##### `물리적 데이터 모델링`
    - 논리 데이터 모델이 데이터 저장소로서 어떻게 컴퓨터 하드웨어에 표현될 것인가를 다룬다.
    - 테이블, 칼럼등으로 표현되는 물리적인 저장 구조와 사용될 저장 장치, 자료를 추출하기 위해 사용될 접근 방법 등이 결정된다.
  
| 데이터 모델링 | 내용 |
| :---: | :----: |     
| 개념적 데이터 모델링 | 추상화 수준이 높고, 엄무중심적이고 포괄적인 수준의 모델링 진행, 전사적 데이터 모델링, EA 수립시 많이 이용 |	
| 논리적 데이터 모델링 | 시스템으로 구축하고자 하는 업무에 대해 Key, 속성, 관계 등을 정확하게 표현, 재사용성이 높음 | 
| 물리적 데이터 모델링 | 실제로 데이터베이스에서 이식할 수 있도록 성능, 저장 등 물리적인 성격을 고려하여 설계 |

### 5️⃣ 프로젝트 생명주기에서 데이터 모델링
![image](https://user-images.githubusercontent.com/87464750/156749242-79d98da7-9db0-4542-887a-1f9900495e5a.png)
  
- 일반적으로 계획 또는 분석단계에서 개념적 데이터 모델링
- 분석단계에서는 논리적 데이터 모델링
- 설계단계에서 물리적 데이터 모델링이 수행된다.
- 단, 현실 프로젝트에서는 개념적 데이터 모델이 생략된 개념/논리 데이터 모델링이 분석단계때 대부분 수행된다.

### 6️⃣ 데이터 모델링에서 데이터독립성의 이해
#### 데이터독립성의 필요성
- 데이터독립성은 지속적으로 증가하는 유지보수 비용을 절감하고 데이터 복잡도를 낮추며 중복된 데이터를 줄이기 위한 목족이 있다.
![image](https://user-images.githubusercontent.com/87464750/156750103-e4b0ff4e-5b52-4cac-89d2-84cd4f4c42b5.png)
  
##### `데이터독립성을 확보하면 얻을 수 있는 효과`
- 각 view의 독립성을 유지하고 계층별 View에 영향을 주지 않고 변경이 가능하다.
- 단계별 Schema에 따라 데이터 정의어와 데이터 조작어가 다름을 제공한다.

#### 데이터베이스 3단계 구조
- ##### `외부 단계`
    - 사용자와 가까운 단계로 사용자 개개인이 보는 자료에 대한 관점과 관련이 있는 부분.
- ##### `개념 단계`
    - 사용자가 처리하는 데이터 유형의 공통적인 사항을 처리하는 통합된 뷰를 데이터 유형의 공통적인 사항을 처리하는 통합된 뷰를 스키마 구조로 디자인한 형태.
- ##### `내부적 단계`
    - 데이터가 물리적으로 저장된 방법에 대한 스키마 구조.
  
#### 데이터독립성 요소
| 항목 | 내용 | 비고 |
| :---: | :----: | :----: |     
| 외부스키마 | - View 단계, 여러 개의 사용자 관점으로 구성, 즉 개개 사용자 단계로서 개개 사용자가 보는 개인적 DB 스키마. </br> - DB의 개개 사용자나 응용프로그래머가 접근하는 DB 정의. | 사용자 관점 </br> 접근하는 특성에 따른 스키마 구성|
| 논리적 데이터 모델링 | - 개념단계, 하나의 개념적 스키마로 구성 모든 사용자 관점을 통합한 조직 전체의 DB를 기술하는 것. </br> - 모든 응용시스템들이나 사용자들이 필요로 하는 데이터를 통합한 조직 전체의 DB를 기술한 것으로 DB에 저장되는 데이터와 그들간의 관계를 표현하는 스키마. | 통합관점 |
| 물리적 데이터 모델링 | - 내부단계, 내부 스키마로 구성, DB가 물리적으로 저장된 형식. </br> - 물리적 장치에서 데이터가 실제적으로 저장되는 방법을 표현하는 스키마 | 물리적 저장구조 |

#### 두 영역의 데이터독립성

| 독립성 | 내용 | 특징 |
| :---: | :----: | :----: |  
| 논리적 독립성 | - 개념 스키마가 변경되어도 외부 스키마에는 영향을 미치지 않도록 지원하는 것. </br> - 논리적 구조가 변경되어도 응용 프로그램에 영향 없음. | - 사용자 특성에 맞는 변경가능 </br> - 통합 구조 변경가능|
| 물리적 독립성 | - 내부스키마가 변경되어도 외부/개념 스키마는 영향을 받지 않도록 지원하는 것. </br> - 저장장치의 구조변경을 응용프로그램과 개념스키마에 영향 없음. | - 물리적 구조 영향없이 개념구조 변경가능. </br> - 개념구조 영향없이 물리적인 구조 변경가능 .|

#### 사상(Mapping)
- 상호 독립적인 개념을 연결시켜주는 다리.

| 사상 | 내용 | 예 |
| :---: | :----: | :----: |  
| 외부적/개념적 사상 </br> (논리적 사상) | - 외부적 뷰와 개념적 뷰의 상호 관련성을 정의함 | 사용자가 접근하는 형식에 따라 다른 타입의 필드를 가질 수 있음. 개념적 뷰의 필드 타입은 변화가 없음. |
| 개념적/내부적 사상 </br> (물리적 사상)| - 개념적 뷰와 저장된 데이터베이스의 상호관련성 정의 | 만약 저장된 데이터베이스 구조가 바뀐다면 개념적/내부적 사상이 바뀌어야 함. 그래야 개념적 스키마가 그대로 남아있게 됨.|

### 7️⃣ 데이터 모델링의 중요한 세 가지 개념
#### 데이터 모델링의 세 가지 요소
- 업무가 관여하는 어떤 것(Things)
- 어떤 것이 가지는 성격(Attributes)
- 업무가 관여하는 어떤 것 간의 관계(relationships)

#### 단수와 집합(복수)의 명명
![image](https://user-images.githubusercontent.com/87464750/156753940-8d8b4589-9595-4b4c-a09d-8be857c4ee6b.png)

### 8️⃣ 데이터 모델링의 이해관계자
#### 데이터 모델링의 이해관계자
- 정보시스템을 구축하는 모든 사람은 데이터 모델링도 전문적으로 할 수 있거나 적어도 완성된 모델을 정확하게 해석할 수 있어야 한다.
    - 즉, 프로젝트에 참여한 모든 IT 기술자들은 데이터 모델링에 대해 정확하게 알고 있어야 한다.
- IT 기술에 종사하거나 전공하지 않았더라도 해당 업무에서 정보화를 추진하는 위치에 있는 사람도 데이터 모델링에 대한 개념 및 세부사항에 대해 어느 정도 지식을 가지고 있어야 한다.

![image](https://user-images.githubusercontent.com/87464750/156754569-9a9cd5e0-c645-4c8d-9c76-f07fe40e7429.png)

### 9️⃣ 데이터 모델의 표기법인 ERD의 이해
#### 데이터 모델 표기법
![image](https://user-images.githubusercontent.com/87464750/156754976-6b16e124-4087-41ce-a40f-c07f7b51689a.png)

- ERD를 작성하는 작업순서
    - 엔터티를 그린다.
        - 가장 중요한 엔터티를 왼쪽 상단에 배치.
    - 엔터티를 적절하게 배치한다.
    - 엔터티간의 관계를 설정한다.
    - 관계명을 기술한다.
    - 관계의 참여도를 기술한다.
    - 관계의 필수여부를 기술한다.

### 🔟 좋은 데이터 모델의 요소
- 완정성(Completeness)
- 중복배제(Non-Redundancy)
- 업무규칙(Business Rules)
- 데이터 재사용(Data Resuability)
- 의사소통(Communicaion)
- 통합성(Integeration)

## 2.
### 1️⃣ 엔터티의 개념
- 사람, 장소, 물건, 사건, 개념 등의 명사에 해당한다.
- 업무상 관리가 필요한 관심사에 해당한다.
- 저장이 되기 위한 어떤것이다.

### 2️⃣ 엔터티와 인스턴스에 대한 내용과 표기법
- 엔터티는 표기법에따라 조금씩 차이는 있지만 대부분 사각형으로 표현된다.
 
<엔터티와 엔터티간의 ERD>

![image](https://user-images.githubusercontent.com/87464750/156874752-a7bc5260-7cf7-4acd-874d-d4f79ab0a565.png)

<엔터티에 대한 표기법>

![image](https://user-images.githubusercontent.com/87464750/156874782-e77274b2-195e-44a5-a1cd-e15f75a99c7f.png)

### 3️⃣ 엔터티의 특징

- 반드시 해당 업무에서 필요하고 관리하고자 하는 정보이여야 한다.
- 유일한 식별자에 의해 식별이 가능해야 한다.
- 영속적으로 존재하는 인스턴스의 집합이여야 한다.
- 업무 프로세스에 의해 이용되어야 한다.
- 반드시 속성이 있어야 한다.
- 다른 엔터티와 최소 한 개 이상의 관계가 있어야 한다.

### 4️⃣ 엔터티의 분류

- ##### `유무형에 따른 분류`
    - `유형엔터티`
        - 물리적인 형태가 있고 안정적이며 지속적으로 활용되는 엔터티
        - 업무로부터 엔터티를 구분하기가 가장 용이하다
        - > ex) 사원, 물품, 강사
    - `개념 엔터티`
        - 물리적인 형태는 존재하지 않고 관리해야 할 개념적 정보로 구분이 되는 엔터티
        - > ex) 조직, 보험상품
    - `사건 엔터티`
        - 업무를 수행함에 따라 발생되는 엔터티로서 비교적 발생량이 많으며 각종 통계자료에 이용될 수 이ㅛ다.
        - > ex) 주문, 청구, 미납
     
- ##### `발생시점에 따른 분류`
    - `기본 엔터티`
        - 그 업무에 원래 존재하는 정보로서 다른 엔터티와 관계에 의해 생성되지 않고 독립적으로 생성이 가능하고 자신은 타 엔터티의 부모의 역할을 하게 된다.
        - 다른 엔터티로부터 주식별자를 상속받지 않고 자신의 고유한 주식별자를 가지게 된다.
    -  `중심엔터티`
        - 기본엔터티로부터 발생되고 그 업무에 있어서 중심적인 역할을 한다.
        - 데이터의 양이 많이 발생되고 다른 엔터티와의 관계를 통해 많은 행위엔터티를 생성한다.
    - `행위엔터티`
        - 두 개 이상의 부모엔터티로부터 발생되고 자주 내용이 바뀌거나 데이터량이 증가된다.
        - 분석초기 단계에서는 잘 나타나지 않으며 상세 설계단계나 프로세스와 상관모델링을 진행하면서 도출될 수 있다.

### 5️⃣ 엔터티의 명명

- 가능하면 현업업무에서 사용하는 용어를 사용한다.
- 가능하면 약어를 사용하지 않는다.
- 단수명사를 사용한다.
- 모든 엔터티에 유일하게 이름이 부여되어야 한다.
- 엔터티 생성의미대로 이름을 부여한다.

## 3.

### 1️⃣ 속성 (Attribute)의 개념

- 업무에서 필요로 한다.
- 의미상 더 이상 분리되지 않는다.
- 엔터티를 설명하고 인스턴스의 구성요소가 된다.

### 2️⃣ 엔터티, 인스턴스와 속성, 속성값에 대한 내용과 표기법
#### 엔터티, 인스턴스, 속성, 속성값의 관계

- 엔터티, 인스턴스, 속성, 속성값에 대한 관계 분석
    - 한 개의 엔터티는 두 개 이상의 인스턴스의 집합이여야 한다.
    - 한 개의 엔터티는 두 개 이상의 속성을 갖는다.
    - 한 개의 속성은 한 개의 속성값을 갖는다.

<엔터티- 속성의 관계>

![image](https://user-images.githubusercontent.com/87464750/156875618-6d556ecc-7405-4ba0-a88a-144ef444c3d7.png)

#### 속성의 표기법
- 속성의 표기법은 엔터티 내에 이름을 포함하여 표현하면 된다.

### 3️⃣ 속성의 특징
- 반드시 해당 업무에 필요하고 관리하고자 하는 정보이여야 한다.
- 정규화 이론에 근간하여 정해진 주식별자에 함수적 종속성을 가져야 한다.
- 하나의 속성에는 한 개의 값만을 가진다.
- 하나의 속성에 여러 개의 값이 있는 다중값일 경우 별도의 엔터티를 이용하여 분리한다.

### 4️⃣ 속성의 분류

- ##### `속성의 특성에 따른 분류 `
    - `기본속성`
        - 업무로부터 추출한 모든 속성이 해당된다.
        - 가장 일반적이고 많은 속성을 차지한다.
        - 코드성 데이터, 엔터티를 식별하기 위해 부여된 일련번호, 그리고 다른 속성을 계산하거나 영향을 받아 생성된 속성을 제외한 모든 속성.
    - `설계속성`
        - 업무상 필요한 데이터 이외에 데이터 모델링을 위해, 업무를 규칙화하기 위해 속성을 새로 만들거나 변형하여 정의하는 속성.
    - `파생속성`
        - 다른 속성에 영향을 받아 발생하는 속성으로 보통 계산된 값들이 이에 해당된다.
        - 프로세스 설계 시 데이터 정합성을 유지하기 위해 유의해야 할 점이 많으며 가급적 파생속성을 적게 정의하는 것이 좋다.

- ##### `엔터티 구성방식에 따른 분류`
    - `PK(Primary Key) 속성`
        - 엔터티를 식별할 수 있는 속성.
    - `FK(Foreign Key) 속성`
        - 다른 엔터티와의 관계에서 포함된 속성.
    - `일반속성`
        - PK, FK에 포함되지 않는 속성.

### 5️⃣ 도메인
- 각 속성이 가질 수 있는 값의 범위.
- 엔터티 내에서 속성에 대한 데이터 타입과 크기 그리고 제약사항을 지정하는 것.
- 속성은 도메인 이외의 값을 갖지 못한다.

### 6️⃣ 속성의 명명
- 해당 업무에서 사용하는 이름을 부여한다.
    - 아무리 일반적인 용어라도 그 업무에서 사용되지 않으면 속성의 명칭으로 사용하지 않는 것이 좋다.
- 서술식 속성명은 상용하지 않는다.
    - 명사형을 이용하고, 수식어가 많이 붙지 않도록 유의하여 작성.
- 약어 사용은 가급적 제한한다.
- 전체 데이터모델에서 유일성을 확보하는 것이 좋다.

## 4.
### 1️⃣ 관계의 정의
- 엔터티의 인스턴스 사이의 논리적인 연관성으로서 존재의 형태로서나 해위로서 서로에게 연관성이 부여된 상태.

#### 관계의 패어링
- 각각의 엔터티의 인스턴스들은 자신이 관련된 인스턴스들과 관계의 어커런스로 참여하는 형태를 관계 패어링이라고 한다.
- 엔터티는 인스턴스의 집합을 논리적으로 표현하였다면 관계는 관계 패어링의 집합을 논리적으로 표현하는 것.

### 2️⃣ 관계의 표기법
- 관계명: 관계의 이름
- 관계차수: 1:1, 1:M, M:N
- 관계선택사양: 필수관계, 선택관계

#### 관계명
- 애매한 동사는 피한다.
- 현재형으로 표현한다.

#### 관계차수

##### `1:1(ONT TO ONE) 관계를 표시하는 방법`

![image](https://user-images.githubusercontent.com/87464750/157227222-7a205bc1-5b8c-4dfb-a63b-6d88c689213d.png)

##### `1:M(ONT TO MANY) 관계를 표시하는 방법`

![image](https://user-images.githubusercontent.com/87464750/157227328-ef248ea1-6844-4b85-aeb8-0c88a7715a4c.png)

##### `M:N(MANY TO MANY) 관계를 표시하는 방법`

![image](https://user-images.githubusercontent.com/87464750/157227388-ea3b9c4e-dfe1-4ac5-b013-9a598c3a7f33.png)

#### 관계선택사양
- ##### `필수참여관계`: 필수적으로 연결 관계가 있는 것.
- ##### `선택적인 관계`: 정보로서 관련은 있지만 서로가 필수적인 관계는 아닌 선택적인 관계가 되는 것.

### 3️⃣ 관계의 정의 및 읽는 방법
#### 관계 체크사항
- 두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
- 두 개의 엔터티 사이에 정보의 조합이 발생되는가?
- 업무기술로서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
- 업무기술서, 장표에 관계연결을 가능하게 하는 동사가 있는가?

#### 관계 읽기
- 기준(Source) 엔터티를 한 개(One) 또는 각(Each)으로 읽는다.
- 대상(Target) 엔터티의 관계참여도 즉 개수(하나, 하나 이상)를 읽는다.
- 관계선택사양과 관계명을 읽는다.

<관계를 읽는 방법>

![image](https://user-images.githubusercontent.com/87464750/157228314-e82e9cc7-8ee0-4e44-93b7-bfd9297b2d09.png)

## 5.
### 1️⃣ 식별자 개념
- 여러 개의 집합체를 담고 있는 하나의 통에서 각각을 구분할 수 있는 논리적인 이름.
- 하나의 엔터티에 구성되어 있는 여러 개의 속성 중에 엔터티를 대표할 수 있는 속성을 의미하며 하나의 엔터티는 반드시 하나의 유일한 식별자가 존재해야 한다.

### 2️⃣ 식별자의 특징
- ##### `유일성` 주식별자에 의해 엔터티내에 모든 인스턴스들의 유일하게 구분되어야 한다.
- ##### `최소성` 주식별자를 구성하는 속성의 수는 유일성을 만족하는 최소의 수가 되어야 한다.
- ##### `불변성` 지정된 주식별자의 값은 자주 변하지 않는 것이어야 한다.
- ##### `존재성` 주식별자가 지정이 되면 반드시 값이 들어와야 한다.

### 3️⃣ 식별자 분류 및 표기볍
#### 식별자 분류
<식별자의 분류 체계>

| 분류 | 식별자 | 설명 |
| :---: | :------: | :------: |  
| 대표성 여부 | 주식별자</br></br> 보조 식별자| - 엔터티 내에서 각 어커런스를 구분 할 수 있는 구분자이며, 타 엔터티와 참조관계를 연결할 수 있는 식별자. </br> - 엔터티 내에서 각 어커런스를 구분할 수 있는 구분자이나 대표성을 가지지 못해 참조관계 연결을 못함.|
| 스스로 생성여부 | 내부식별자 </br></br> 외부식별자| - 엔터티 내부에서 스스로 만들어지는 식별자. </br></br> - 타 엔터티와의 관계를 통해 타 엔터티로부터 받아오는 식별자. |
| 속성의 수 | 단일 식별자 </br> 복합 식별자| - 하나의 속성으로 구성된 식별자. </br></br> - 둘 이상의 속성으로 구성된 식별자 |
| 대체 여부 | 본질 식별자 </br> 인조식별자 |- 업무에 의해 만들어지는 식별자 </br></br> - 업무적으로 만들어지지는 않지만 원조식별자가 복잡한 구성을 가지고 있기 때문에 인위적으로 만든 식별자. |


### 4️⃣ 주식별자 도출기준
- 해당 업무에서 자주 이용되는 속성을 주식별자로 지정한다.
- 명칭, 내역 등과 같이 이름으로 기술되는 것들은 가능하면 주식별자로 지정하지 않는다.
- 복합으로 주식별자로 구성할 경우 너무 많은 속성이 포함되지 않도록 한다.

### 5️⃣ 식별자관계와 비식별자관계에 따른 식별자

#### 식별자관계와 비식별자 관계의 결정
- 엔터티에 주식별자가 지정되고 엔터티간 관계를 연결하면 부모쪽의 주식별자를 자식엔터티의 속성으로 내려 보낸다.
- 이때 자식엔터티에서 부모엔터티로부터 받은 외부식별자를 자신의 주식별자로 이용할 것인지 또는 부모와 연결이 되는 속성으로서만 이용할 것인지를 결정해야 한다.

#### 식별자관계
- 부모로부터 받은 식별자를 자식엔터티의 주식별자로 이용하는 경우 Null 값이 오면 안되므로 반드시 부모엔터티가 생성되어야 자기 자신의 엔터티가 생성되는 경우이다.
- `1:1 관계` 부모로부터 받은 속성을 자식엔터티가 모두 사용하고 그것만으로 주식별자로 사용하는 경우.
- `1:M 관계` 부모로부터 받은 속성을 포함하여 다른 부모엔터티에서 받은 속성을 포함하거나 스스로 가지고 있는 속성과 함께 주식별자로 구성되는 경우.

#### 비식별자관계
비식별자 관계: 부모엔터티로부터 속성을 받았지만 자식엔터티의 주식별자로 사용하지 않고 일반적인 속성으로만 사용하는 경우.
- 자식엔터티에서 받은 속성이 반드시 필수가 아니어도 무방하기 때문에 부모없는 자식이 생성될 수 있는 경우.
- 엔터티별로 데이터의 생명주기를 다르게 관리할 경우.
- 여러 개의 엔터티가 하나의 엔터티로 통합되어 표현되었는데 각각의 엔터티가 별도의 관계를 가질 경우.
- 자식엔터티에 주식별자로 사용하여도 되지만 자식엔터티에서 별도의 주식별자를 생성하는 것이 더 유리하다고 판단될 때 비식별자 관계에 의한 외부식별자로 표현.

#### 식별자 관계로만 설정할 경우의 문제점
- 식별자 관계만으로 연결된 데이터 모델의 특징은 주식별자 속성이 지속적으로 증가할 수 밖에 없는 구조로서 개발자가 복잡성과 오류가능성을 유발시킬 수 있는 요인이 될 수 있다.

#### 비식별자 관계로만 설정할 경우의 문제점
- 일반적으로 각각의 엔터티에는 중요한 기준 속성이 있는데 이러한 기준속성은 부모엔터티에 있는 PK 속성으로부터 상속되어 자식엔터티에 존재하는 경우가 많다.
- 이런 경우 데이터 모델링을 전개할 때 각 엔터티 간의 관계를 비식별자 관계로 설정하면 이런 유형의 속성이 자식엔터티로 상속이 되지 않아 자식엔터티에서 데이터를 처리할 때 쓸데없이 부모엔터티까지 찾아가여 하는 경우가 발생된다.

#### 식별자관계와 비식별자관계 모델링
- 비식별자관계 선택 프로세스
- 다음 조건에 해당할 경우 비식별자관계로 조정

![image](https://user-images.githubusercontent.com/87464750/158022564-261f46e6-5333-468f-93bf-170338d82212.png)

- 식별자와 비식별자관계 비교

| 항목 | 식별자관계 | 비식별자관계 |
| :---: | :------: | :------: |  
| 목적 | 강한 연결관계 표현 | 약한 연결관계 표현|
| 자식 주식별자 영향 | 자식 주식별자의 구성에 포함됨 | 자식 일반 속성에 포함됨 |
| 표기법 | 실선 표현 | 점선 표현 |
| 연결 고려사항 | - 반드시 부모엔터티 종속 </br> - 자식 주식별자구성에 부모 주식별자포함 필요 </br> - 상속받은 주식별자속성을 타 엔터티에 이전 필요| - 약한 종속관계 </br> - 자식 주식별자구성을 독립적으로 구성 </br> - 자식 주식별자구성을 부모 주식별자 부분 필요 </br> - 상속받은 주식별자속성을 타 엔터티에 차단 필요 </br> -부모쪽의 관계참여자가 선택관계 |

 </div>
</details>

<details>
  
<summary> ✏ 데이터 모델의 성능 </summary>
<div markdown="1">
  
## 1.
### 1️⃣ 성능 데이터 모델링의 정의
- 성능 데이터 모델링이란 데이터베이스 성능향상을 목적으로 설계 단계의 데이터 모델링 때부터 정규화, 반정규화, 테이블통합, 테이블분할, 조인구조, PK, FK 등 여러 가지 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것으로 정의.
  
### 2️⃣ 성능 데이터 모델링 수행시점
- 분석/설계 단계에서 데이터베이스 처리 성능을 향상시킬 수 있는 방법을 주도면밀하게 고려해야 한다.
  
<성능 향상 그래프>
  
![image](https://user-images.githubusercontent.com/87464750/158052546-e9e035b8-b2f3-495c-b9f9-1d8cd65c0d29.png)
  
### 3️⃣ 성능 데이터 모델링 고려사항
- 데이터 모델링을 할 때 정규화를 정확하게 수행한다.
    - 정규화된 모델이 데이터를 주요 관심사별로 분산시키는 효과가 있기 때문에 그 자체로 성능을 향상시키는 효과가 있다.
- 데이터베이스 용량산정을 수행한다.
    - 용량산정을 수행하면 어떤 엔터티에 데이터가 집중되는지 파악 할 수 있다.
- 데이터베이스에 발생되는 트랜잭션의 유형을 파악한다.
    - SQL 문장의 조인관계 테이블에서 데이터조회의 칼러들을 파악할 수 있게 되어 그에 따라 성능을 고려한 데이터 모델을 설계할 수 있다.
- 용량과 트랜잭션의 유형에 따라 반정규화를 수행한다.
     - 반정규화는 테이블, 속성, 관계에 대해 포괄적인 반정규화의 방법을 적용해야 한다.
- 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다.
- 성능관점에서 데이터 모델을 검증한다.
    - 일반적인 데이터 모델 규칙만을 검증하지 말고 충분하게 성능이 고려되었는지를 체크리스트에 포함하여 검증하도록 한다.
  
### 4️⃣ 정규하 성능1. 정규화를 통한 성능 향상 전략
- 데이터 모델링을 하면서 정규화를 하는 것은 기본적으로 데이터에 대한 중복성을 제거하여 주고 데이터가 관심사별로 처리되는 경우가 많기 때문에 성능이 향상되는 특징을 가지고 있다.
- 엔터티가 계속 발생되므로 SQL 문장에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우도 있다.
  
<정규화 수행과 성능>
  
![image](https://user-images.githubusercontent.com/87464750/158052933-56a6639b-58da-4416-bf3b-25db90a43ca4.png)
  
- 정규화 수행 모델은 데이터를 입력/수정/삭제할 때 일반적으로 반졍규화된 테이블에 비해 처리 성능이 향상된다.
- 단, 데이터를 조회할 때에는 처리 조건에 따라 조회 성능이 향상될 수도 있고 저하될 수도 있다.
- 따라서 일반적으로 정규화가 잘 되어 있으면 입력/수정/삭제의 성능이 향상되고 반정규화를 많이하면 조회의 성능이 향상된다고 인식될 수 있다.
  
### 5️⃣ 함수적 종속성에 근거한 정규화 수행 필요
- 함수의 종속성은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다.
- 이때 기준값을 결정자라 하고 종속되는 값을 종속자라고 하다.
<함수의 종속성>

![image](https://user-images.githubusercontent.com/87464750/158053067-5495c55f-92cd-4482-a705-40b3112f79ed.png)
  
- 함수의 종속성은 데이터가 가지고 있는 근본적인 속성으로 인식되고 있다.
- 정규화의 궁극적인 목적은 반복적인 데이터를 분리하고 각 데이터가 종속된 테이블에 적절하게 배치되도록 하는 것이므로 이 함수의 종속성을 이용하여 정규화 작업이나 각 오브젝트에 속성을 배치하는 작업에 이용되는 것이다.
  
## 2.
### 1️⃣ 반정규화를 통한 성능향상 전략
#### 반정규화의 정의
- 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법을 의미한다.
  
<중복성의 원리를 활용하여 데이터조회시 성능을 향상시키는 역할을 할 수 있음>
 
![image](https://user-images.githubusercontent.com/87464750/165761949-1d4e79f2-4c42-40a5-9aa9-848989271629.png)
  
- 반정규화를 기술적으로 수행하지 않는 경우에 발생하는 현상
    - 성능이 저하된 데이터베이스가 생성될 수 있다.
    - 구축단계나 시험단계에서 반정규화를 적용할 때 수정에 따른 노력비용이 많이 들게된다.

#### 반정규화의 적용방법
  
<반정규화 절차>

![image](https://user-images.githubusercontent.com/87464750/166789424-1fa97163-caef-4c6c-b5a1-2d8961143b16.png)
  
- 반정규화 대상을 조사한다.
    - 일단 전체 데이터의 양을 조사하고 그 데이터가 해당 프로세스를 처리할 때 성능저하가 나타날 수 있는지 검증해야한다.
        - 자주 사용되는 테이블에 접근하는 프로세스의 수가 많고 항상 일정한 범위만을 조회하느 경우에 반정규화를 검토한다.
        - 테이블에 대량의 데이터가 있고 대량의 데이터 범위를 자주 처리하는 경우에 처리범위를 일정하게 줄이지 않으면 성능을 보장할 수 없을 경우에 반정규화를 검토한다.
        - 통계성 프로세스에 의해 통계 정보를 필요로 할 때 별도의 통계테이블을 생성한다.
        - 테이블에 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 반졍규화를 검토한다.
  
- 반정규화의 대상에 대해 다른 방법으로 처리할 수 있는지 검토한다.
  - 지나치게 많은 조인이 걸려 데이터를 조회하는 작업이 기술적으로 어려울 경우 뷰를 사용하면 이를 해결할 수도 있다.
  - 대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우에 클러스터링을 적용하거나 인덱슬르 조정함으로써 성능을 향상시킬 수 있다.
  - 대량의 데이터는 Primary key의 성격에 따라 부분적인 테이블로 분리할 수 있다.
  - 응용 에플리케이션에서 로직을 구하는 방법을 변경함으로써 성능을 향상시킬 수 있다.
- 반정규화를 적용한다.
  
### 2️⃣ 반정규화의 기법
- 테이블 반정규화
  
<테이블 병합>
| 기법 | 내용 |
| :---: | :----: |     
| 1:1 관계 테이블 병합 | 1:1 관계를 통합하여 성능향상 |	
| 1:M 관계 테이블 병합 | 1:M 관계를 통합하여 성능향상 | 
| 슈퍼/서브타입 테이블 병합 | 슈퍼/서브 관계를 통합하여 성능향상 |

<이블 분할>
| 기법 | 내용 |
| :---: | :----: |     
| 수직분할 | 칼럼단위의 테이블을 디스크 I/O를 분산처리 하기 위해 테이블을 1:1로 분리하여 성능향상(트랜잭션의 처리되는 유형을 파악이 선행되어야 함) |	
| 수평분할 | 로우 단위로 집중 발생되는 트랜잭션을 분석하여 디스크 I/O 및 데이터접근의 효율성을 높여 성능을 향상하기 위해 로우단위로 테이블 쪼갬 | 

<테이블 추가>
| 기법 | 내용 |
| :---: | :----: |     
| 중복 테이블 추가 | 다른 업무이거나 서버가 다른 경우 동일한 테이블구조를 중복하여 원격조인을 제거하여 성능을 향상 |	
| 통계테이블 추가 | SUM, AVG 등을 미리 수행하여 계산해 둠으로써 조회 시 성능을 향상 | 
| 이력테이블 추가 | 이력테이블 중에서 마스터 테이블에 존재하는 레코드를 중복하여 이력테이블에 존재하는 방법은 반정규화의 유형 |
| 부분테이블 추가 | 하나의 테이블의 전체 칼럼 중 자주 이용하는데 자주 이용하는 집중화된 칼럼들이 있을 때 디스크 I/O를 줄이기 위해 해당 칼럼들을 모아놓은 별도의 반정규화된 테이블을 작성|
  
- 칼럼의 반정규화
  
| 기법 | 내용 |
| :---: | :----: |     
| 중복칼럼 추가 | 조인에 의해 처리할 때 성능저하를 예방하기 위해 즉, 조인을 감소시키기 위해 중복된 칼럼을 위치시킴 |	
| 파생칼럼 추가 | 트랜잭션이 처리되는 시점에 계산에 의해 발생되는 성능저하를 예방하기 위해 미리값을 계산하여 칼럼에 보관함. Derived Column이라고 함 | 
| 이력테이블 칼럼추가 | 대량의 이력데이터를 처리할 때 불특정 날 조회나 최근 값을 조회할 때 나타날 수 있는 성능저하를 예방하기 위해 이력테이블에 가능성 칼럼(최근값 여부, 시작과 종료일자 등)을 추가함  | 
| PK에 위한 칼럼 추가  | 복합의미를 갖는 PK를 단일 속성으로 구성하였을 경우 발생됨. 단일 PK안에서 특정값을 별도로 조회화는 경우 성능저하가 발생될 수 있음. 이때 이미 PK안에 데이터가 존재하지만 성능향상을 위해 일반속성으로 포함하는 방법이 PK의한 칼럼추가 반정규화임. | 
| 응용시스템 오작동을 위한 칼럼 추가 | 업무적으로는 의미가 없지만 사용자가 데이터처리를 하다가 잘못 처리하여 원래 값으로 북구하기를 원하는 경우 이전 데이터를 임시적으로 중복하여 보관하는 기법. 칼럼으로 이것을 보관하는 방법은 오작동 처리를 위한 임시적인 기법이지만 이것을 이력데이터 모델로 풀어내면 정상적인 데이터 모델의 기법이 될 수 있음. |
| 중복관계 추가 | 데이터를 처리하기 위한 여러 경로를 거쳐 조인이 가능하지만 이때 발생할 수 있는 성능저하를 예방하기 위해 추가적인 관계를 맺는 방법이 관계의 반정규화임|
  
 ## 3.
 ### 1️⃣ 대량 데이터발생에 따른 테이블 분할개요
 
 - 대량의 데이터가 처리되는 테이블에 성능이 저하되는 이유는 SQL 문장에서 데이터를 처리하기 위한 I/O의 양이 증가하기 때문이다.
 - 대량의 데이터가 존재하는 테이블에 많은 트랜잭션이 발생하여 성능이 저하되는 테이블 구조에 대해 수평/수직 분할 설계를 통해 성능저하를 예방할 수 있음
 
  <테이블 수평/수직분할에 의한 성능향상>
    
 ![image](https://user-images.githubusercontent.com/87464750/169698305-cb991bea-4f5d-490d-9b21-25d8cf62b6ad.png)
  
  - 칼럼이 많이지게 되면 물리적인 디스크에 여러 블록에 데이터가 저장되게 된다. 따라서 데이터를 처리할때 여러 블록에서 데이터를 I/O해야 하는 즉 SQL 문장의 성능이 저하될 수 있는 특징을 가지게 된다.
 
 <디스크에 데이터저장의 개념>
   
 ![image](https://user-images.githubusercontent.com/87464750/169698875-021f04cd-d306-4eb5-9ba5-6064a777947c.png)
 
- 많은 컬럼은 로우체이닝과 로우마이그레이션이 많아지게 되어 성능이 저하된다.
- 로우체이닝: 로우 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않고 두 개 이상의 블록에 걸쳐 하나의 로우가 저장되어 있는 형태.
- 로우마이그레이션: 데이터 블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장하는 방식.
- 로우체이닝과 로우마이그레이션이 발생하여 많은 블록에 데이터가 저장되면 데이터베이스 메모리에서 디스크와 I/O 가 발생할때 불필요하게 I/O가 많이 발생하여 성능이 저하된다.
   
### 2️⃣ 한 테이블에 많은 수의 칼럼을 가지고 있는 경우
- 물리적으로 칼럼의 값이 블록에 넓게 산재되어 있어 디스크 I/O가 많이 일어나게 된다.
- 많은 칼럼을 가지고 있는 테이블에 대해서는 트랜잭션이 발생될 때 어떤 칼럼에 대해 집중적으로 발생하는지 분석하여 테이블을 쪼개어 주면 디스크 I/O가 감소하게 되어 성능이 개선되게 된다.
- 분리된 테이블은 디스크에 적어진 칼럼이 저장이 되므로 로우마이그레이션과 로우체이닝이 많이 줄어들 수 있다.
    - 동일한 SQL 구분에 대해서도 디스크 I/O가 줄어들어 성능이 개선되게 된다.
    - 트랜잭션을 분석하여 적절하게 1:1 관계로 분리함으로써 성능향상이 가능하도록 해야한다.
 
### 3️⃣ 대량 데이터 저장 및 처리로 인한 성능
- 테이블에 많은 양의 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법을 적용할 수 있다.

##### RANGE PARTITION 적용
- 하나의 테이블로는 너무 많은 데이터가 존재하므로 인해 성능이 경우헤 해당된다.
- 가장 많이 사용하는 파티셔닝의 기준이다.
- 대상 테이블이 날자 또는 숫자값으로 분리가 가능하고 각 영역별로 트랜잭션이 분리된다면 RANGE PARTITION을 적용한다.
- 데이터보관주기에 따라 테이블에 데이터를 쉽게 지우는 것이 가능하므로 데이터보관주기에 따른 테이블 관리가 용이하다.
   
##### LIST PARTITION 적용
- 핵심적인 코드값 등으로 PK가 구성되어 있고, 대량의 데이터가 있는 테이블이라면 값 각각에 의해 파티셔닝이 되는 LIST PARTITION을 적용할 수 있다.
- 대용량 데이터를 특정값에 따라 분리 저장할 수 있으나 RANGE PARTITION과 같이 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.
   
##### HASH PARTITION 적용
- 지정된 HASH 조건에 따라 해슁 알고리즘이 적용되어 테이블이 분리되며 설계자는 테이블에 데이터가 정확하게 어떻게 들어갔는지 알 수 없다.
- 성능향상을 위해 사용하며 데이터 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없다.
   
데이터량이 대용량이 되면 파티셔닝의 적용은 필수적으로 파티셔닝 기준을 나눌 수 있는 조건에 따라 적절한 파티셔닝 방법을 선택하여 성능을 향상 시키도록 한다.
   
### 4️⃣ 테이블에 대한 수평분할/수직분할의 절차

` 수평분할/수직분할에 대한 4가지 원칙 `
   
1. 데이터 모델링을 완성한다.
2. 데이터베이스 용량산정을 한다.
3. 대량 데이터가 처리되는 테이블에 대해서 트랜잭션 처리 패턴을 분석한다.
4. 칼럼 단위로 집중화된 처리가 발생하는지, 로우단위로 집중화된 처리가 발생되는지 분석하여 집중화된 단위로 테이블을 분리하는 것을 검토한다.
   
- 용량산정은 어느 테이블에 데이터의 양이 대용량이 되는지 분석하는 것이다.
- 특정 테이블의 용량이 대용량인 경우 칼럼의 수가 너무 많은지 확인한다.
        - 칼럼의 수가 많은 경우 트랜잭션의 특성에 따라 테이블을 1:1 형태로 분리할 수 있는지 검증하면 된다.
- 칼럼의 수가 적지만 데이터용량이 많아 성능저하가 예상이 되는 경우 테이블에 대해 파티셔닝 전략을 고려하도록 한다.
        - 이때, 임의로 파티셔닝을 할것인지 데이터가 발생되는 시간에 따라 파티셔닝을 할 것인지를 설명된 기준에 따라 적용하면 된다.
   
 ## 4
 ### 1️⃣ 슈퍼타입/서브타입 모델의 성능고려 방법
 ##### 슈퍼/서브타입 데이터 모델의 개요
   
 - 최근에 데이터 모델링을 할 때 자주 쓰이는 모델링 방법.
 - 자주쓰이는 이유: 업무를 구성하는 데이터의 특징을 공통과 차이점의 특징을 고려하여 효과적으로 표현할 수 있기 때문이다.
          - 즉, 공통의 부분을 슈퍼타입으로 모델링 하고 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분하여 업무의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환을 할 때 선택의 폭을 넓힐 수 있는 장점이 있다.
 
 </div>
</details>
